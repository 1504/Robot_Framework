package org.usfirst.frc.team1504.robot;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.stream.Collectors;
import java.util.HashMap;

import edu.wpi.first.wpilibj.vision.VisionPipeline;

import org.opencv.core.*;
import org.opencv.core.Core.*;
import org.opencv.features2d.FeatureDetector;
import org.opencv.imgcodecs.Imgcodecs;
import org.opencv.imgproc.*;
import org.opencv.objdetect.*;
//import org.usfirst.frc.team1504.robot.Vision.AimState;
import org.usfirst.frc.team1504.robot.Vision.AimState;


/**
* GripPipelineee class.
*
* <p>An OpenCV pipeline generated by GRIP.
*
* @author GRIP
*/
public class GripPipelineee implements VisionPipeline {

	//Outputs
	private Mat hsvThresholdOutput = new Mat();
	private Mat cvErodeOutput = new Mat();
	private ArrayList<MatOfPoint> findContoursOutput = new ArrayList<MatOfPoint>();
	//public List<MatOfPoint> _contours;
	public double[][] _output;
	public double _hue1;
	public double _hue2;
	public double _sat1;
	public double _sat2;
	public double _val1;
	public double _val2;
	public double _circ1;
	public double _circ2;
	public Vision.AimState _state;
	public double _target = 0.0;


	static {
		System.loadLibrary(Core.NATIVE_LIBRARY_NAME);
	}

	/**
	 * This is the primary method that runs the entire pipeline and updates the outputs.
	 */
	@Override	public void process(Mat source0) 
	{
		process(source0, _hue1, _hue2, _sat1, _sat2, _val1, _val2, _circ1, _circ2);
	}
	
	public void process(Mat source0, double hue1, double hue2, double sat1, double sat2, double val1, double val2, double circ1, double circ2)
	{
		// Step HSV_Threshold0:
		hue1 = _hue1;
		System.out.println("in process from pipeline");
		Mat hsvThresholdInput = source0;
		double[] hsvThresholdHue = {hue1, hue2}; //{0.0, 56.23089983022071};
		double[] hsvThresholdSaturation = {sat1, sat2}; //{153.64208633093526, 198.7181663837012};
		double[] hsvThresholdValue = {val1, val2}; //{192.62589928057554, 255.0};
		hsvThreshold(hsvThresholdInput, hsvThresholdHue, hsvThresholdSaturation, hsvThresholdValue, hsvThresholdOutput);
		
		// Step CV_erode0:
		Mat cvErodeSrc = hsvThresholdOutput;
		Mat cvErodeKernel = new Mat();
		Point cvErodeAnchor = new Point(-1, -1);
		double cvErodeIterations = 1;
		int cvErodeBordertype = Core.BORDER_CONSTANT;
		Scalar cvErodeBordervalue = new Scalar(-1);
		cvErode(cvErodeSrc, cvErodeKernel, cvErodeAnchor, cvErodeIterations, cvErodeBordertype, cvErodeBordervalue, cvErodeOutput);

		// Step Find_Contours0:
		Mat findContoursInput = cvErodeOutput;
		boolean findContoursExternalOnly = false;
		_output = findContours(findContoursInput, findContoursExternalOnly, findContoursOutput);
		
		System.out.println("inside vision update");
		double[] area = _output[4];
		double[] position = _output[0];

		if(area.length == 0)
		{
			_state = Vision.AimState.BAD_IMAGE;
			return;
		}
		
		int largest = 0;
		for(int i = 0; i < area.length; i++)
		{
			if(area[i] < area[largest])
			{
				largest = i;
			}
		}
		
		_target = largest;
		System.out.println("largest target is " + _target);
		_target = (2 * position[largest] / 160) - 1; //width is 160
		_target *= 120 / -2.0; //height is 120
		
		checkAim();

	}
	

	public void checkAim()
	{
		if(offset_aim_factor() < .75)
		{
			_state = AimState.AIMED;
			System.out.println("aimed");
		}
		
		else
		{
			_state = AimState.AIM_ROBOT;
			System.out.println("need to aim");

		}
	}
	
	private double offset_aim_factor()
	{
		//return _target - _gyro.getAngle(); // offset
		return 1.0; //TODO - put gyro back in when we have it
	}

	/**
	 * This method is a generated getter for the output of a HSV_Threshold.
	 * @return Mat output from HSV_Threshold.
	 */
	public Mat hsvThresholdOutput() {
		return hsvThresholdOutput;
	}

	/**
	 * This method is a generated getter for the output of a CV_erode.
	 * @return Mat output from CV_erode.
	 */
	public Mat cvErodeOutput() {
		return cvErodeOutput;
	}

	/**
	 * This method is a generated getter for the output of a Find_Contours.
	 * @return ArrayList<MatOfPoint> output from Find_Contours.
	 */
	public ArrayList<MatOfPoint> findContoursOutput() {
		return findContoursOutput;
	}


	/**
	 * Segment an image based on hue, saturation, and value ranges.
	 *
	 * @param input The image on which to perform the HSL threshold.
	 * @param hue The min and max hue
	 * @param sat The min and max saturation
	 * @param val The min and max value
	 * @param output The image in which to store the output.
	 */
	private void hsvThreshold(Mat input, double[] hue, double[] sat, double[] val,
	    Mat out) {
		Imgproc.cvtColor(input, out, Imgproc.COLOR_BGR2HSV);
		Core.inRange(out, new Scalar(hue[0], sat[0], val[0]),
			new Scalar(hue[1], sat[1], val[1]), out);
	}

	/**
	 * Expands area of lower value in an image.
	 * @param src the Image to erode.
	 * @param kernel the kernel for erosion.
	 * @param anchor the center of the kernel.
	 * @param iterations the number of times to perform the erosion.
	 * @param borderType pixel extrapolation method.
	 * @param borderValue value to be used for a constant border.
	 * @param dst Output Image.
	 */
	private void cvErode(Mat src, Mat kernel, Point anchor, double iterations,
		int borderType, Scalar borderValue, Mat dst) {
		if (kernel == null) {
			kernel = new Mat();
		}
		if (anchor == null) {
			anchor = new Point(-1,-1);
		}
		if (borderValue == null) {
			borderValue = new Scalar(-1);
		}
		Imgproc.erode(src, dst, kernel, anchor, (int)iterations, borderType, borderValue);
	}

	/**
	 * Sets the values of pixels in a binary image to their distance to the nearest black pixel.
	 * @param input The image on which to perform the Distance Transform.
	 * @param type The Transform.
	 * @param maskSize the size of the mask.
	 * @param output The image in which to store the output.
	 */
	private double[][] findContours(Mat input, boolean externalOnly,
		List<MatOfPoint> contours) {
		Mat hierarchy = new Mat();
		contours.clear();
		int mode;
		if (externalOnly) {
			mode = Imgproc.RETR_EXTERNAL;
		}
		else {
			mode = Imgproc.RETR_LIST;
		}
		int method = Imgproc.CHAIN_APPROX_SIMPLE;
		Imgproc.findContours(input, contours, hierarchy, mode, method);
		
		Rect[] bb = new Rect[(int) contours.size()];
		double[][] output = {
				new double[(int) contours.size()],
				new double[(int) contours.size()],
				new double[(int) contours.size()],
				new double[(int) contours.size()],
				new double[(int) contours.size()]
				};
		
		for(int i = 0; i < contours.size(); i++)
		{
			bb[i] = Imgproc.boundingRect(contours.get(i));
			
			output[0][i] = bb[i].x + bb[i].width / 2.0;
			output[1][i] = bb[i].y + bb[i].height;// / 2.0;
			output[2][i] = bb[i].width;
			output[3][i] = bb[i].height;
			output[4][i] = Imgproc.contourArea(contours.get(i), false);
			//contours.get(i).
			System.out.println(bb[i].x + " " + bb[i].y + " " + bb[i].width + " " + bb[i].height + " " + output[4][i]);
		}
		
		//_contours = contours;
		_output = output;
		return _output;
	}

	

}

